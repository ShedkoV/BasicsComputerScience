# Введение в Python

1. [Первая программа](#first_code)
2. [Типы данных и операции](#data_types)
3. [Строки и операции над ними](#strigns)

### <a name="first_code"> </a> ТПервая программа
- Первая программа на Python выглядит следующим образом:
  ```python
  print("Hello World")
  ```
  Данная программа выведет в консоль сообщение `Hello World`.
  Для того, чтобы выводить сообщения используется функция `print()`, а то, что в нее передается(в нашем случае `"Hello World"`), называется аргументом функции.
- Программу `Hello World` можно написать и другим способом:
  ```python
  print("Hello", "World")
  ```
  В данном случае было передано 2 аргумента: `"Hello"`, `"World"`, а Python их сам склеил в одно сообщение и поставил пробел между словами. Если мы захотели бы выводить каждое слово на новой строке, то на пришлось бы поменять "разделитель", который по умолчанию является пробелом. Делается это передачей именованного аргумента `sep` - separator(разделитель):
  ```python
  print("Hello", "World", sep="\n")
  ```
  Данная программа выведет все слова на отдельных строках. В качестве разделителя используется `"\n"` - один из символов [escape-последовательности](https://wiki.dieg.info/escape), обозначающий перевод новой строки.
- Если мы попробуем вывести несколько фраз разными функциями вывода:
  ```python
  print("Hello World")
  print("It's me!")
  ```
  то каждая фраза выведется на новой строке, потому что по умолчанию `print()` ставит символ новой строки `"\n"` в конце каждого сообщения(в сыром виде вывод выглядит как `Hello World\nIt's me!\n`, просто консоль эту фразу делает красивой). Однако можно было бы вывести данную строку по-другому, например `Hello World! It's me!`, в данном случае мы хотим, чтобы вместо символа новой строки, была последовательность символов `"! "`, делается это с помощью именованного аргумента `end`:
  ```python
  print("Hello World", end="! ")
  print("It's me!")
  ```
  теперь вывод будет иметь форму, которую мы хотели: `Hello World! It's me!`. Таким образом можно модифицировать вывод в консоль)
### <a name="data_types"> </a> Типы данных и операции
- Объявление переменных происходит следующим образом:
    ```Python
        count = 0 # число
        name = "Bob" # строка
        size = 12.9 # десятичное число
        is_active = True # булевая переменная(с большой буквы)
    ```
- Название переменной(идентификаторы) - это то, как вы можете обращаться к значению в данной переменной, например:
    ```Python
    students_number = 13
    teachers_number = 1
    people_number = students_number + teachers_number
    ```
- Работа со строкой и числом
    ```Python
    students_number = 13
    teachers_number = '1'
    people_number = students_number + teachers_number
    ```
  Пример выше вызовет ошибку `TypeError: unsupported operand type(s) for +: 'int' and 'str'`, потому что `students_number` - типа **int**, а `teachers_number` - типа **str**, для исправления данной ошибки нужно сказать интерпретатору, что мы хотим иметь дело с int типом, этот прием называется приведением типов:
    ```Python
    students_number = 13
    teachers_number = '1'
    people_number = students_number + int(teachers_number) # привели тип! Получили 14 в ответе
    ```
  Точно так же можно привести int к str:
    ```Python
    students_number = 13
    teachers_number = '1'
    people_number = str(students_number) + teachers_number # привели тип! Получили "131" в ответе
    ```
- Операции над числами:
    ```Python
    5 + 3 # сложение, результат 8
    5 - 3 # разность, результат 2
    5 * 3 # умножение, результат 15
    5 ** 3 # возведение в степень, результат 125
    5 / 3 # деление, результат 1.6666666666666667
    5 // 3 # целочисленное деление, результат 1
    5 % 3 # взятие остатка, результат 2
    ```
- Операции над строками:
    ```Python
    "a" + "b" # конкатенация, результат "ab"
    "a" * 10 # можно делать так, результат "aaaaaaaaaa"
    ```
- Операции над логическими переменными:
    ```Python
    True and False # логическое "и", результат False
    True or False # логическое "или", результат True
    not True # логические "не", результат False
    ```
### <a name='strigns'>Строки и операции над ними</a>
- Строки в Python представляют собой набор символов, а значит можно обращаться к символам следующим образом:
  ```python
  name = "Bob"
  o = name[1] # в переменной o будет символ "o"
  ```
  однако строки являются неизменным типом данных:
  ```python
  name = "Bob"
  name[0] = "a" # сделать так нельзя, будет ошибка.
  ```
- Строки это набор символов, а значит их можно приводить ко всем коллекциям:
  ```python
  random_string = "some_string"
  string_list = list(random_string)
  print(string_list) # ['s', 'o', 'm', 'e', '_', 's', 't', 'r', 'i', 'n', 'g']
  ```
- Строки имеют множество особых методов, которые могут помочь с работой с ними:
    - `lower()` - метод для превращения всех букв в слове в маленькие:
      ```python
      name = "alEX"
      lower_name = name.lower()
      print(name) # alEX
      print(lower_name) # alex
      ```
    - `upper()` - переводит все буквы строки в верхний регистр:
      ```python
      name = "alEX"
      lower_name = name.upper()
      print(lower_name) # ALEX
      ```
    - `capitalize()` - делает первую букву строки большой, а остальные маленькими:
      ```python
      name = "alEX"
      lower_name = name.capitalize()
      print(lower_name) # Alex
      ```
    - `join(collection)` - превращает все элементы какой-то коллекции в строку, ставя между ними, как разделитель, строку, к которой применили данный метод:
      ```python
      collection = ["1", "2", "3", "4", "5"]
      some_sep = "! "
      another_sep = "$$$"
      collection_string = some_sep.join(collection)
      another_collection_string = another_sep.join(collection)
      print(collection_string) # 1! 2! 3! 4! 5
      print(another_collection_string) # 1$$$2$$$3$$$4$$$5
      ``` 
    - `replace(old_label, new_label)` - создает новую строку, где заменяет все old_label на new_label:
      ```python
      name = "alexe"
      changed_name = name.replace("e", "OOO")
      print(changed_name) # alOOOxOOO
      ```
- Интерполяция строк - форматирование строк, где форматирование происходит при помощи [плейсхолдеров](https://blog.calltouch.ru/plejsholdery-chto-eto-takoe-i-stoit-li-ispolzovat/). Если упростить, то это процесс форматирования строк, где данные, которые пока неизвестны, заменяются на определенные символы, которые можно подставить позже. В Python представлены 3 вида интерполяции строк:
  - через `%`:
    ```python
    # придумали шаблон, где заменили все неизвестные данные на плейсхолдеры
    template = "%s is %s. He is %s."
    ...
    # спустя какое-то время появились данные
    name = "Alex"
    age = 22
    job = "engineer"

    sentence = template % (name, age, job) # подставили в шаблон все данные и положили в переменную
    # важно помнить, что сам шаблон при этом не меняется
    # так как строки это неизменяемый тип данных.
    # этот шаблон потом можно переиспользовать в другом месте.
    print(sentence) # Alex is 22. He is engineer.
    ```
    Интерполяция через % это довольно старый вид интерполяции, он используется только в тех случаях, где безопасность данных играет малую роль, так как он уязвим к [SQL-инъекциям](https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_SQL-%D0%BA%D0%BE%D0%B4%D0%B0)
  - через метод `format()`:
    ```python
    # придумали шаблон, где заменили все неизвестные данные на плейсхолдеры
    template = "{} is {}. He is {}."
    ...
    # спустя какое-то время появились данные
    name = "Alex"
    age = 22
    job = "engineer"

    sentance = template.format(name, age, job) # подставили в шаблон все данные и положили в переменную
    print(sentance) # Alex is 22. He is engineer.
    ```
  - f-строки. При данном способе интерполяции необходимо объявлять используемые переменные до шаблона:
    ```python
    # Сначала объявляем переменные
    name = "Alex"
    age = 22
    job = "engineer"
    
    setnance = f"{name} is {age}. He is {job}."
    
    print(setnance) # Alex is 22. He is engineer.
    ```
    Этот способ не создает промежуточного шаблона, а сразу подставляет данные, при объявлении шаблона.
  - (extra) Операции можно выполнять прямо в шаблонах, например данный код является валидным:
    ```python
    name = "Alex"
    weight = 59
    height = 1.78

    sentance_1 = f"{name}'s BMI is {weight/(height**2):.2f}." # вычисляем формулу прямо в строке!

    sentance_2 = "{}'s BMI is {:.2f}.".format(name, weight/(height**2))

    sentance_3 = "%s's BMI is %.2f." % (name, weight/(height**2))

    print(sentance_1)
    print(sentance_2)
    print(sentance_3)
    ```
    Кроме того в данном примере заданы органичения на вывод вещественной части чисел, в случаях format и f-строк, это делается через `:.2f` - вывести 2 знака после запятой, в случе `%`, это просто `%.2f`. Если их убрать(поэксперементируйте), запись вещественной части будет слишком большой. Можно писать любое число вместо двойки, которое будет обозначать количество символов после запятой, которое вам удобно.
  - Это основные виды интерполяции строк, однако каждый из них имеет свои подтипы, которые можно найти в сети Internet =), они не так часто используются, так что я не вижу смысла ими здесь загружать голову.